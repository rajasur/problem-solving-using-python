# Remove Outermost Parentheses

---

## Problem Statement

A valid parentheses string is defined as:

- `""` (empty string)
- `"(" + A + ")"` where A is a valid parentheses string
- `A + B` where A and B are valid parentheses strings

A **primitive** parentheses string is a non-empty valid parentheses string that cannot be split into two non-empty valid parentheses strings.

Given a valid parentheses string `s`, decompose it into its primitive components and remove the **outermost parentheses** from each primitive substring. Return the resulting string.

---

## Examples

### Example 1

```
Input:  s = "(()())(())"
Output: "()()()"
Explanation:
Primitive decomposition: "(()())" + "(())"
After removing outer parentheses: "()()" + "()" = "()()()"
```

### Example 2

```
Input:  s = "(()())(())(()(()))"
Output: "()()()()(())"
```

### Example 3

```
Input:  s = "()()"
Output: ""
```

---

## Constraints

- `1 <= s.length <= 10^5`
- `s[i]` is either `'('` or `')'`
- `s` is a valid parentheses string

---

# Approaches

## 1. Brute Force Approach — Substring Detection

### Idea

- Track parentheses balance.
- Each time balance becomes 0, we have a primitive substring.
- Remove its first and last character and append to result.

### Algorithm

1. Initialize:
    - `result = ""`
    - `start = 0`
    - `balance = 0`
2. Iterate through `s`:
    - If `'('` → `balance += 1`
    - If `')'` → `balance -= 1`
    - If `balance == 0`:
        - Extract `s[start+1 : i]` and append to result.
        - Set `start = i + 1`.
3. Return `result`.

### Code

```python
def removeOuterParentheses_brute(s: str) -> str:
    result = ""
    start = 0
    balance = 0
    for i, ch in enumerate(s):
        if ch == '(':
            balance += 1
        else:
            balance -= 1
        if balance == 0:
            result += s[start + 1:i]
            start = i + 1
    return result
```

### Complexity

- **Time:** `O(N^2)` (due to substring creation)
- **Space:** `O(N)`

---

## 2. Better Approach — Stack

### Idea

- Use a stack to track parentheses nesting.
- Only add characters if they are not the outermost parentheses.

### Algorithm

1. Initialize:
    - Empty `stack`
    - Empty `result` list
2. Traverse each character:
    - If `'('`:
        - If stack not empty → append to result
        - Push `'('` to stack
    - If `')'`:
        - Pop from stack
        - If stack not empty → append to result
3. Join `result` and return.

### Code

```python
def removeOuterParentheses_better(s: str) -> str:
    stack = []
    result = []
    for ch in s:
        if ch == '(':
            if stack:
                result.append(ch)
            stack.append(ch)
        else:
            stack.pop()
            if stack:
                result.append(ch)
    return "".join(result)
```

### Complexity

- **Time:** `O(N)`
- **Space:** `O(N)`

---

## 3. Optimal Approach — Depth Counter

### Idea

- Maintain a counter for the current depth of parentheses.
- Append `(` only if we are **inside** (depth > 0 before increment).
- Append `)` only if we are **inside** (depth > 0 after decrement).
- Avoids extra stack storage.

### Algorithm

1. Initialize:
    - `counter = 0`
    - `ans = ""`
2. For each character in `s`:
    - If `)` → decrement `counter`
    - If `counter != 0` → append character to `ans`
    - If `(` → increment `counter`
3. Return `ans`.

### Code

```python
class Solution:
    def removeOuterParentheses(self, s: str) -> str:
        ans = ""
        counter = 0
        for character in s:
            if character == ")":
                counter -= 1
            if counter != 0:
                ans += character
            if character == "(":
                counter += 1
        return ans
```

### Complexity

- **Time:** `O(N)`
- **Space:** `O(N)`

---

## Final Recommendation

- Use the **Optimal Approach (Depth Counter)** — clean, single-pass, and no stack overhead.
- Brute force is easier to reason about but not efficient for large inputs.
- Stack is good for visualization but has more memory overhead.

